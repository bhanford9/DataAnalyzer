using DataAnalyzer.ApplicationConfigurations;
using DataAnalyzer.Common.Mvvm;
using DataAnalyzer.Services;
using DataAnalyzer.Services.Enums;
using DataAnalyzer.StatConfigurations;
using DataScraper.DataScrapers.ImportTypes;
using DataScraper.DataScrapers.ScraperCategories;
using DataScraper.DataScrapers.ScraperFlavors;
using System;
using System.IO;

namespace DataAnalyzer.Models;

internal class ConfigurationModel : BasePropertyChanged, IConfigurationModel
{
    private readonly ISerializationService serializer;

    // These fields are set on page zero and allow the user to have different application configurations
    // This can help compartmentalize if the application grows to be large
    private string configurationDirectory = string.Empty;
    private string configurationName = "MyAppConfig";
    private string configurationFilePath = string.Empty;

    private string executiveConfigurationDirectory = string.Empty;
    private string executiveConfigurationName = string.Empty;

    private IImportType importType = null;
    private IScraperCategory category = null;
    private IScraperFlavor flavor = null;
    private IStatsConfiguration dataConfiguration = new NotSupportedDataConfiguration();
    private ExecutionType selectedExecutionType = ExecutionType.NotApplicable;
    private IImportExecutionKey importEecutionKey = Services.ImportExecutionKey.Default;

    // This refers to where data configurations are stored which is an autogenerated path based on the others, so this is OBE
    private string savedDataFilePath = string.Empty;

    public ConfigurationModel(ISerializationService serializationService)
    {
        this.serializer = serializationService;
        this.ConfigurationDirectory = Properties.Settings.Default.LastUsedApplicationRootDirectory;
        this.ConfigurationName = Properties.Settings.Default.LastUsedApplicationConfigurationName;
        this.LoadConfiguration();

        // TODO --> this should have a save/apply method
        // TODO --> main model should be updating this guy with import/category/flavor/execution (the properties don't need to be here)
        // TODO --> make sure to handle partially set types
    }

    public IImportExecutionKey ImportExecutionKey
    {
        get => this.importEecutionKey;
        set
        {
            this.NotifyPropertyChanged(ref this.importEecutionKey, value);
            this.importType = value.ImportKey.Type;
            this.category = value.ImportKey.Category;
            this.flavor = value.ImportKey.Flavor;
            this.selectedExecutionType = value.ExecutionType;
            this.NotifyPropertyChanged(nameof(this.ImportType));
            this.NotifyPropertyChanged(nameof(this.Category));
            this.NotifyPropertyChanged(nameof(this.Flavor));
            this.NotifyPropertyChanged(nameof(this.SelectedExecutionType));

            // TODO --> the library needs to support import/category/flavor/execution
            // TODO --> I think I want to move this to the stats model?
            //this.DataAccessorCollection = this.dataAccessorLibrary.GetStatAccessors(StatType.NotApplicable);
        }
    }

    public ExecutionType SelectedExecutionType
    {
        get => this.selectedExecutionType;
        set
        {
            if (this.selectedExecutionType != value)
            {
                this.selectedExecutionType = value;
                this.NotifyPropertyChanged(nameof(this.SelectedExecutionType));
            }

            if (this.ImportExecutionKey.ExecutionType != value)
            {
                this.ImportExecutionKey.Update(value);
                this.NotifyPropertyChanged(nameof(this.ImportExecutionKey));
            }                
        }
    }

    public IImportType ImportType
    {
        get => this.importType;
        set
        {
            if (this.importType != value)
            {
                this.ImportExecutionKey.Update(value);
                this.NotifyPropertyChanged(nameof(this.ImportExecutionKey));
                this.NotifyPropertyChanged(ref this.importType, value);
            }
        }
    }

    public IScraperCategory Category
    {
        get => this.category;
        set
        {
            if (this.category != value)
            {
                this.ImportExecutionKey.Update(value);
                this.NotifyPropertyChanged(nameof(this.ImportExecutionKey));
                this.NotifyPropertyChanged(ref this.category, value);
            }
        }
    }

    public IScraperFlavor Flavor
    {
        get => this.flavor;
        set
        {
            if (value != null && this.flavor != value)
            {
                this.ImportExecutionKey.Update(value);
                this.NotifyPropertyChanged(nameof(this.ImportExecutionKey));
                this.NotifyPropertyChanged(ref this.flavor, value);
            }
        }
    }

    public IStatsConfiguration DataConfiguration
    {
        get => this.dataConfiguration;
        set => this.NotifyPropertyChanged(ref this.dataConfiguration, value);
    }

    /// <summary>
    /// Location where last-application-state will be stored
    /// </summary>
    public string ConfigurationDirectory
    {
        get => this.configurationDirectory;
        set
        {
            this.NotifyPropertyChanged(ref this.configurationDirectory, value);

            Properties.Settings.Default.LastUsedApplicationRootDirectory = value;
            Properties.Settings.Default.Save();
            this.ApplyFilePath();
        }
    }

    /// <summary>
    /// Location where the import/execution combination's configuration is stored
    /// </summary>
    public string ExecutiveConfigurationDirectory
    {
        get => this.executiveConfigurationDirectory;
        set => this.NotifyPropertyChanged(ref this.executiveConfigurationDirectory, value);
    }


    /// <summary>
    /// Name of last-application-state file
    /// </summary>
    public string ConfigurationName
    {
        get => this.configurationName;
        set
        {
            this.NotifyPropertyChanged(ref this.configurationName, value);
            Properties.Settings.Default.LastUsedApplicationConfigurationName = value;
            Properties.Settings.Default.Save();
            this.ApplyFilePath();
        }
    }

    /// <summary>
    /// Name of the import/execution combination's configuration
    /// </summary>
    public string ExecutiveConfigurationName
    {
        get => this.executiveConfigurationName;
        set => this.NotifyPropertyChanged(ref this.executiveConfigurationName, value);
    }

    public string ConfigurationFilePath
    {
        get => this.configurationFilePath;
        set => this.NotifyPropertyChanged(ref this.configurationFilePath, value);
    }

    // This refers to where data configurations are stored which is an autogenerated path based on the others, so this is OBE
    public string SavedDataFilePath
    {
        get => this.savedDataFilePath;
        set => this.NotifyPropertyChanged(ref this.savedDataFilePath, value);
    }

    public void ApplyConfiguration(IImportType import, IScraperCategory category, IScraperFlavor flavor)
    {
        this.ImportType = import;
        this.Category = category;
        this.Flavor = flavor;
    }

    public bool HasLoaded { get; private set; } = false;

    public void SaveConfiguration()
    {
        ApplicationConfiguration config = new()
        {
            SelectedImport = this.importType,
            SelectedCategory = this.category,
            SelectedFlavor = this.flavor,
            SelectedExecution = this.selectedExecutionType,
            DateTime = DateTime.Now,
        };

        serializer.JsonSerializeToFile(config, this.configurationFilePath);
    }

    public bool LoadConfiguration()
    {
        try
        {
            ApplicationConfiguration config = serializer.JsonDeserializeFromFile<ApplicationConfiguration>(this.configurationFilePath);
            this.ImportType = config.SelectedImport;
            this.Category = config.SelectedCategory;
            this.Flavor = config.SelectedFlavor;
            this.SelectedExecutionType = config.SelectedExecution;

            this.ImportExecutionKey = new ImportExecutionKey(
                new ImportKey(this.ImportType, this.Category, this.Flavor),
                this.SelectedExecutionType);

            // TODO - MAIN -->  I think I need to convert this application configuration to the correct DataConfiguration

            return this.HasLoaded = true;
        }
        catch
        {
            return this.HasLoaded = false;
        }
    }

    private void ApplyFilePath()
    {
        string filePath = Path.Combine(this.configurationDirectory, this.configurationName);

        if (!filePath.EndsWith(".json"))
        {
            filePath += ".json";
        }

        if (File.Exists(filePath))
        {
            this.ConfigurationFilePath = filePath;
            this.LoadConfiguration();
        }
    }
}
